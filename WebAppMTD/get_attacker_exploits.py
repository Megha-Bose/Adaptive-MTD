"""
Extracting vulnerabilities in technologies and storing it as:
vuls[<tech>][<cve_id>][<score_name>]

Then, extracting which vulnerabilities and their corresponding base scores each attacker type can exploit 
based on exploitability score and attacker type expertise in each technology.
"""

import json
import numpy as np
import matplotlib.pyplot as plt


# List of years to check for vulnerabilities
years = [2020, 2021, 2022]

# Function to check if a vulnerability affects a specific technology (e.g., Python)
def affects_technology(vulnerability_data, technology):
    configurations = vulnerability_data.get('configurations', {})
    nodes = configurations.get('nodes', [])
    for node in nodes:
        cpe_match = node.get('cpe_match', [])
        for match in cpe_match:
            cpe23Uri = match.get('cpe23Uri', '')
            if technology in cpe23Uri:
                return True
    return False

# Function to extract scores from vulnerability data
def extract_scores(vulnerability_data):
    base_metric_v2 = vulnerability_data.get('impact', {}).get('baseMetricV2', {})

    exploitability_score_v2 = base_metric_v2.get('exploitabilityScore', None)
    # base_score_v3 = base_metric_v3.get('cvssV3', {}).get('baseScore', None)
    impact_score_v2 = base_metric_v2.get('impactScore', None)
    
    return {
        'ES': exploitability_score_v2,
        # 'BS': base_score_v3,
        'IS': impact_score_v2,
    }

def get_vulnerabilities(technologies_to_check):
    # Dictionary to store vulnerabilities for each technology
    vuls = {}
    for technology_to_check in technologies_to_check:
        vuls[technology_to_check] = {}

    # Iterate over selected years and load vulnerability data
    for year in years:
        f = open('./data/nvd_based/nvdcve-1.1-' + str(year) + '.json')
        data = json.load(f)
        for vul in data['CVE_Items']:
            for technology_to_check in technologies_to_check:
                if affects_technology(vul, ':' + technology_to_check + ':'):
                    scores = extract_scores(vul)
                    vuls[technology_to_check][vul['cve']['CVE_data_meta']['ID']] = scores

    # Find and print common vulnerabilities between pairs of technologies
    for i in range(len(technologies_to_check)):
        for j in range(i+1, len(technologies_to_check)):
            tech1 = technologies_to_check[i]
            tech2 = technologies_to_check[j]
            common_vulnerabilities = [value for value in list(vuls[tech1].keys()) if value in list(vuls[tech2].keys())]
            # if len(common_vulnerabilities):
            #     print(f"Common Vulnerabilities between {tech1} and {tech2}:")
            #     for cve_id in common_vulnerabilities:
            #         print(cve_id)
            #     print()
    
    return vuls


def plot_exploitability_scores(techs):
    for technology_to_plot in techs:

        # Call the get_vulnerabilities function to retrieve vulnerability data
        vuls = get_vulnerabilities([technology_to_plot])

        # Extract the exploitability scores for the selected technology
        exploitability_scores = [vuls[technology_to_plot][cve_id]['ES'] for cve_id in vuls[technology_to_plot]]

        # Define score ranges and their corresponding frequencies
        score_ranges = np.arange(0.0, 5.0, 0.25)
        frequency = [0] * (len(score_ranges) - 1)

        # Count the frequencies of scores within each range
        for score in exploitability_scores:
            for i in range(len(score_ranges) - 1):
                if score_ranges[i] <= score < score_ranges[i + 1]:
                    frequency[i] += 1

        # Create a bar plot to visualize the frequency of exploitability scores in each range
        plt.figure(figsize=(20, 5))
        plt.bar(range(len(frequency)), frequency, align='center', width=0.4)
        plt.xticks(range(len(score_ranges) - 1), [f"{score_ranges[i]}-{score_ranges[i + 1]}" for i in range(len(score_ranges) - 1)])
        plt.xlabel('Exploitability Score Range')
        plt.ylabel('Frequency')
        plt.title(f'Exploitability Score Frequency for {technology_to_plot}')
        plt.savefig(technology_to_plot +'_vuls_exploit_scores.png')


def get_exploits_by_attacker_types(att_type_exp, vuls):
    exploits = {}
    for type, exp in att_type_exp.items():
        exploits[type] = {}
        num = 0
        for tech, expertise in exp.items():
            avg_es = 0
            c1 = 0
            avg_is = 0
            c2 = 0
            for _, val in vuls[tech].items():
                if val['ES'] != None and val['IS'] != None and val['ES'] <= expertise:
                    avg_es = avg_es * c1 + val['ES']
                    c1+=1
                    avg_es = avg_es / c1
                    avg_is = avg_is * c2 + val['IS']
                    c2+=1
                    avg_is = avg_is / c2
                    num+=1
            exploits[type][tech] = (round(avg_es * 0.1, 2), round(avg_is * 10))
        print("\nNumber of Attacks that can be exploited by " + str(type) + ": ", num)
    return exploits


def get_exploit_sets(sys_techs, sys_att_type_exp):
    vuls = get_vulnerabilities(sys_techs)
    exploit_sets = get_exploits_by_attacker_types(sys_att_type_exp, vuls)
    return exploit_sets
  